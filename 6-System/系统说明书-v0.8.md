# AoYi 外挂大脑系统说明书（v0.8）

版本：v0.8
更新时间：2026-02-15
适用仓库：`AoYiSecond-cc-light`
运行引擎：Claude Code Runtime

---

## 1. 为什么做这套系统

### 1.1 问题

人的认知带宽有限。每天接收大量信息、做大量决策，但：
- 好想法转眼就忘，下次遇到同样问题还是从零开始
- 跨领域的知识明明相关，但大脑不会自动建立连接
- 项目切换时上下文丢失，AI 每次都要重新解释背景
- 笔记越积越多，但很少被回头调用，沦为信息坟场

### 1.2 答案

让 AI 成为第二认知层——它记住你积累的所有知识，理解你当前的处境，在你需要的时候主动把相关的东西拿出来。

不是"帮你记笔记"，而是"帮你用知识"。

---

## 2. 给谁做

奥一（用户）。一个在创业、内容创作、AI 产品之间多线程并行的人。

使用场景：
- 在做 AI 产品营销时，系统自动调出上次定义的产品定位和目标人群
- 在写文章时，系统关联已有的写作方法论和案例库
- 在做决策时，系统找出历史上类似的决策记录和复盘教训
- 在探索新领域时，系统发现跨领域的共性模式

一个人用，所有交互入口是 Claude Code 对话。没有前端界面，没有 Web 服务。Obsidian 是存储层，Claude Code 是引擎层。

---

## 3. 设计哲学

### 3.1 核心信条：更多智能，更少控制

**用 prompt 引导 AI 的判断力，而不是用代码控制 AI 的行为。**

- 能用 prompt 解决的，不写脚本
- 能用 markdown 传递的，不用 JSON 配置
- 能靠 AI 判断的，不靠硬编码规则
- 代码只做 AI 做不好的事：启动检测、索引统计、审计记录

### 3.2 五条铁律

1. **用户目标优先** — 系统维护是服务手段，不是目的
2. **分层治理** — A 类自动执行，B/C 类必须审批
3. **同构原则** — 结构是内容的镜像，内容是结构的灵魂，两相必须一致
4. **奥卡姆剃刀** — 能简单就简单，三行重复代码好过一个过早的抽象
5. **可追溯** — 变更有日志，审批有记录，记忆有来源

### 3.3 Markdown 是一切

Markdown 在这套系统里承担三重角色：

| 角色 | 说明 | 例子 |
|------|------|------|
| 记忆介质 | 人的知识存在 .md 文件里 | 方法论、决策记录、学习笔记 |
| 上下文载体 | AI 通过读 .md 理解系统状态 | CLAUDE.md、CONTEXT.md、OPERATING_RULES.md |
| 通信协议 | 系统组件之间通过 .md 传递信息 | pending_approvals.md、tag_vocabulary.md |

不用数据库，不用自定义格式。Markdown 对人可读、对 AI 可理解、对 Obsidian 原生兼容。

---

## 4. 架构

### 4.1 目录结构（PARA）

```
AoYiSecond-cc-light/
├── 0-Inbox/          输入收集箱，未分类内容暂存
├── 1-Projects/       项目，有明确目标和截止日期
├── 2-Areas/          责任领域，持续维护无终点
├── 3-Resources/      资源库，可复用的参考资料
│   ├── 创作/         写作、自媒体、视频、内容创作
│   ├── 商业/         产品、创业、战略、商业模式
│   ├── AI/           提示词、工具技巧、Agent
│   ├── 理财/         投资、现金流、资产配置
│   └── 认知/         思维模型、价值观（跨域复用）
├── 4-Archives/       归档库，已完成但保留
├── 5-Identity/       身份画像，变更必须审批
│   ├── TELOS.md      使命/目标/信念/策略
│   ├── AI_RULES.md   AI 行为准则
│   └── CONTEXT.md    当前上下文（A类自动更新）
├── 6-System/         系统运行支持
│   ├── hooks/        Hook 脚本
│   ├── scripts/      维护脚本
│   ├── indexes/      检索索引
│   ├── working-memory/       跨会话记忆
│   ├── state/        运行状态
│   └── logs/         审计日志
└── .claude/          Claude Code 配置
    ├── CLAUDE.md     L1 系统宪法
    ├── settings.json 运行时配置
    └── skills/       技能定义
```

### 4.2 三层分形文档（L1/L2/L3）

这是整套系统最核心的设计。

```
L1  .claude/CLAUDE.md        系统宪法 — 全局规则、设计原则、铁律
     ↓ 折叠
L2  各目录/CLAUDE.md          局部地图 — 这个目录是干什么的、有哪些成员
     ↓ 折叠
L3  笔记 frontmatter          内容契约 — 这篇文件属于哪、是什么类型、什么标签
```

**为什么叫"分形"**：每一层的结构和上一层自相似。L1 定义了系统的骨架，L2 在自己的目录里重复这个骨架，L3 在单篇文件里再重复一次。AI 进入任何层级，都能看到同样模式的结构信息。

**为什么这样设计**：AI 的上下文窗口有限，不可能把整个知识库一次性读进去。分形结构让 AI 可以"逐层下钻"——先看 L1 了解全局，再看 L2 了解某个目录，再看 L3 了解某篇文件。每一层都是自足的。

### 4.3 运行时架构

```
.claude/settings.json
├── contextFiles → 每次会话自动注入 TELOS/AI_RULES/CONTEXT/MEMORY
├── hooks
│   ├── SessionStart → startup.py（轻量健康检测，输出摘要）
│   └── Stop → stop_audit.py（日常记忆写入，审计日志）
└── skills → intake / digest / writing / maintain
```

**设计选择**：hooks 只做代码擅长的事（统计、检测、文件写入），Claude 做 AI 擅长的事（理解、判断、关联、生成）。两者通过 markdown 文件交接。

---

## 5. 核心系统

### 5.1 知识资产系统

**目的**：把碎片信息变成可调用的知识。

**存储**：PARA 目录 + L3 frontmatter 元数据。每篇文件携带：

```yaml
---
para: resource          # 属于 PARA 的哪个分区
domain: 创作            # 所属领域
type: 方法论            # 结构标签（内容形态）
tags: [写作系统, 观点打磨]  # 主题标签（跨域桥梁）
status: active          # 状态
layer: 本质             # 认知层级（仅 Resources）
summary: 一句话摘要
created: 2026-02-15
updated: 2026-02-15
reviewed_at: 2026-02-15
---
```

**索引**：`build_pointers.py` 扫描全库，为每篇文件生成一条知识指针（`knowledge_pointers.jsonl`），包含标题、路径、标签、摘要、排名评分。AI 通过读索引快速定位相关知识，不需要遍历文件系统。

**调用**：AI 在对话中根据话题自动检索相关知识。由 L1 CLAUDE.md 的 `<RETRIEVAL>` 规则驱动——这不是代码逻辑，是 prompt 指令。AI 自己判断什么时候该去找什么。

### 5.2 记忆系统

**目的**：让 AI 在跨会话之间记住用户。

**三层记忆**：

| 层 | 载体 | 写入方式 | 生命周期 |
|---|---|---|---|
| 日常碎片 | `working-memory/daily/{YYYYMM}/{YYYYMMDD}.md` | Stop hook 自动写入 | 短期，定期压缩 |
| 长期记忆 | `working-memory/OPERATING_RULES.md` | Claude 建议 + 用户同意 | 持久 |
| 身份记忆 | `5-Identity/TELOS.md` + `CONTEXT.md` | CONTEXT 自动更新 / TELOS 需审批 | 持久 |

**怎么做到跨会话连续**：

`settings.json` 的 `contextFiles` 配置了 4 个文件在每次会话启动时自动注入：
- `TELOS.md` — AI 知道你是谁、目标是什么
- `AI_RULES.md` — AI 知道怎么服务你
- `CONTEXT.md` — AI 知道你最近在做什么项目
- `OPERATING_RULES.md` — AI 知道你的长期偏好

这意味着：你上一次对话说"我在做 AI 产品叫 MyWear，针对北美健身人群"，CONTEXT.md 会被更新。下次打开新窗口，AI 直接知道这个背景，不需要你重复说明。

### 5.3 身份系统

**目的**：保护用户的核心画像不被随意修改。

**TELOS.md** 定义了奥一的使命（M#）、目标（G#）、挑战（C#）、策略（S#）、信念（B#）、框架（FR#）、模型（MO#）、经历（TR#）。这是系统中**唯一需要 B 类审批才能修改的内容**。

**为什么单独保护**：Identity 决定了 AI 的服务方向。如果 AI 可以自由修改你的使命和信念，它就可能把你带偏。所以任何涉及 Identity 的变更必须写提案、等审批、有回滚方案。

**CONTEXT.md** 则是 A 类自动更新——AI 在对话中识别到"你开始了新项目"或"你进入了新阶段"时，直接更新。这是安全的，因为 CONTEXT 是事实描述，不是价值判断。

### 5.4 标签系统

**目的**：让知识可被发现、可被关联、不会爆炸。

**二层设计**：

| 层 | 字段 | 含义 | 控制模式 |
|---|---|---|---|
| 结构标签 | `type` | 内容形态（方法论/笔记/决策/案例/提示词/价值观/体系/设定/作品） | 受控增长 |
| 主题标签 | `tags` | 内容主题（写作系统/商业模式/Prompt...） | 半开放，Claude 去重 |

**Source of Truth**：`6-System/indexes/tag_vocabulary.md`，统一定义所有结构标签和主题标签的含义、涉及领域、使用计数。

**自维护闭环**（三层频率）：

```
日常轻维护（零额外触发）
  ← L1 CLAUDE.md 知识库卫生规则驱动
  → 入库时自动检查标签复用、补空描述、检查 L2 成员清单、修正 L3 para

索引重建时自动体检
  ← build_pointers.py 运行时自动调用
  → 生成 kb_health.json（标签/结构/知识味道/索引新鲜度 四维检测）

定期深度维护（用户手动触发 /maintain）
  ← 每 1-2 周一次
  → 子命令覆盖：tags（标签）/ structure（L2/L3）/ smells（坏味道）/ indexes（索引）/ full（全部）

启动提醒（代码层，零 token）
  ← startup.py 读 kb_health.json + maintenance.json
  → 超 5 天未维护提示 (建议: /maintain)
```

### 5.5 归档系统

**目的**：把碎片信息内化到知识体系。

**入口**：`/intake` skill。工作流：

```
Inbox 原始内容
  → 分析本质、判断 PARA 归属
  → 读目标目录 L2 了解分类惯例
  → 展示归档方案（路径、文件名、frontmatter、标签）
  → 用户确认
  → 写入目标位置 + 更新 L2 成员清单 + 删除 Inbox 原文件
```

### 5.6 写作系统

**目的**：用奥一的风格和方法论输出内容。

**入口**：`/writing` skill。根据任务类型加载不同规则文件：

```
2-Areas/WritingSystem/
├── CORE.md                    主体提示词
└── WriteRule/
    ├── 标题写作指南.md
    ├── 爆款开头写作指南.md
    ├── 认知升维写作指南.md
    └── ...
```

写作时可检索 `knowledge_pointers.jsonl` 注入相关知识作为素材。

### 5.7 治理系统

**目的**：保证系统不会失控。

**变更分级**：

| 级别 | 说明 | 例子 | 处理 |
|------|------|------|------|
| A 类 | 常规操作 | 入库、标签补全、CONTEXT 更新 | 自动执行 |
| B 类 | 分类/身份变更 | TELOS 修改、新增结构标签 | 写提案，等审批 |
| C 类 | 系统规则变更 | 修改 L1 CLAUDE.md | 写提案，等审批 |

**审批流**：提案写入 `6-System/pending_approvals.md` → 用户决策 → `approve_change.sh` 执行状态转换 → 记录到 `change_log.md`。

---

## 6. 怎么做到设计哲学的

### 6.1 "更多智能更少控制"怎么落地

L1 CLAUDE.md 不是"配置文件"，它是系统的灵魂。AI 读了它就知道该怎么做——什么时候该搜索知识、什么时候该写提案、什么时候该提醒用户。

| 能力 | 实现方式 | 为什么 |
|---|---|---|
| 意图判定 | L1 `<CAPABILITIES>` prompt 规则 | AI 判断力比规则匹配更灵活 |
| 知识关联 | L1 `<RETRIEVAL>` prompt 规则 | AI 自己决定什么时候搜什么 |
| 标签卫生 | L1 知识库卫生规则 + `/maintain` skill | 日常靠 prompt，深度靠 skill |
| 归档入库 | `/intake` skill | prompt 定义工作流 |
| 对话收纳 | `/digest` skill | prompt 定义工作流 |
| 启动检测 | `startup.py` 代码 | 扫描文件做统计，代码更擅长 |
| 索引构建 | `build_pointers.py` 代码 | 遍历 200+ 文件，代码更高效 |
| 记忆碎片写入 | `stop_audit.py` 代码 | 解析 transcript，代码更可靠 |
| 记忆压缩 | `memory_consolidate.py` 代码 | 去重和裁剪是机械操作 |
| 审批状态机 | `approve_change.sh` 代码 | 状态转换需要原子性 |

**分界线**：需要理解、判断、关联、生成的，交给 prompt。需要扫描、统计、去重、文件写入的，交给代码。两者通过 markdown 文件交接。

### 6.2 "同构原则"怎么落地

每次内容变更后，系统执行回环检查：

```
L3 检查 → 元数据与实际内容一致？
L2 检查 → 成员清单需要更新？
L1 检查 → 目录结构或分类体系变化？
```

这不是代码逻辑，是写在 L1 CLAUDE.md `<WORKFLOW>` 里的 prompt 规则。AI 每次做完修改会自动检查。如果发现结构和内容不同步（知识坏味道），会立即指出。

### 6.3 "奥卡姆剃刀"怎么落地

整套系统只保留 4 个脚本，做 AI 不擅长的事：

| 脚本 | 职责 | 为什么用代码 |
|------|------|-----------|
| `build_pointers.py` | 索引构建 + 标签统计 + 健康报告 | AI 不擅长扫描 200+ 文件做统计 |
| `build_para_overview.py` | PARA 全局概览 | 同上 |
| `memory_consolidate.py` | 记忆压缩 + TELOS 候选提炼 | 去重和压缩是机械操作 |
| `approve_change.sh` | 提案状态机 | 状态转换需要原子性 |

其他能力全部由 prompt + skill 承载：
- 意图判定 → L1 `<CAPABILITIES>` + `<RETRIEVAL>` 规则
- 知识关联 → L1 `<RETRIEVAL>` 主动关联规则
- 标签卫生 → L1 `<CAPABILITIES>` 知识库卫生规则 + `/maintain` skill
- 归档入库 → `/intake` skill
- 对话收纳 → `/digest` skill

---

## 7. 具体实现

### 7.1 会话启动（SessionStart hook）

**文件**：`6-System/hooks/startup.py`

```
输入：para_overview.json, kb_health.json, maintenance.json, pending_approvals.md
处理：读文件 → 统计 → 拼摘要（零 AI 调用）
输出：一行启动摘要
```

输出示例：
```
[系统启动] 知识库 209 篇 | 1 个待审批提案 | 健康: 1严重, 12警告 (维护已7天, 建议: /maintain)
```

同时 `settings.json` 的 `contextFiles` 自动注入 TELOS/AI_RULES/CONTEXT/MEMORY，AI 立即进入有上下文的工作状态。

### 7.2 会话结束（Stop hook）

**文件**：`6-System/hooks/stop_audit.py`

```
输入：transcript（对话记录）
处理：提取用户消息首行 → 写入 daily 记忆文件
输出：working-memory/daily/{YYYYMM}/{YYYYMMDD}.md
```

轻量级，只记碎片。深度记忆沉淀由 `/digest` skill 或 Claude 日常对话中的主动建议完成。

### 7.3 知识指针构建

**文件**：`6-System/scripts/build_pointers.py`

```
输入：PARA 0-5 目录下所有 .md 文件
处理：
  1. 解析 frontmatter → 提取 para/domain/type/tags/status/summary
  2. 计算 rank = PARA权重×0.55 + 状态权重×0.2 + 置信度×0.25
  3. 计算 freshness（基于 reviewed_at）
  4. 更新 tag_vocabulary.md 主题标签表（保留描述，更新计数）
  5. 生成 kb_health.json（四维健康检测：标签/结构/知识味道/索引新鲜度）
输出：
  - knowledge_pointers.jsonl（209 条知识指针）
  - tag_vocabulary.md（更新计数）
  - kb_health.json（知识库健康报告）
```

### 7.4 技能系统

| Skill | 触发 | 做什么 |
|-------|------|--------|
| `/intake` | "归档"、"入库"、"整理 inbox" | Inbox → PARA 归档，含标签选取、L2 更新 |
| `/digest` | "总结对话"、"归入系统"、"收纳" | 对话 → CONTEXT/MEMORY/知识沉淀 |
| `/writing` | "写文章"、"改标题"、"优化开头" | 加载写作规则 → 按风格输出 |
| `/maintain` | "维护"、"体检"、"清理标签" | 全面诊断 + 子命令：tags/structure/smells/indexes/full |

每个 skill 是一个 `SKILL.md` 文件，用 prompt 定义工作流。不是代码，是给 AI 的行为指南。

### 7.5 上下文注入链

```
每次会话启动时：

[settings.json contextFiles]
  → 加载 TELOS.md         AI 知道用户是谁
  → 加载 AI_RULES.md      AI 知道怎么服务
  → 加载 CONTEXT.md       AI 知道用户最近在做什么
  → 加载 OPERATING_RULES.md        AI 知道用户的长期偏好

[settings.json hooks.SessionStart]
  → startup.py            AI 收到系统健康摘要

[.claude/CLAUDE.md]  (L1 宪法，始终加载)
  → AI 知道所有规则、分形结构、回环原则、标签卫生…
```

这条链保证了：**每次打开新的 Claude Code 窗口，AI 都不是从零开始。**

---

## 8. 用户操作指南

### 日常（每次对话）

什么都不用做。启动时看一眼摘要，正常跟 AI 对话即可。

### 每周建议

- 看一眼 `6-System/pending_approvals.md`，处理待审批提案
- 跑一次 `/maintain` 做知识库维护（系统会自动提醒）

### 偶尔

- `/digest` 把重要对话归入系统
- `/intake` 整理 Inbox 里堆积的内容

### 审批命令

```bash
bash 6-System/scripts/approve_change.sh list        # 列出提案
bash 6-System/scripts/approve_change.sh approve <id> # 批准
bash 6-System/scripts/approve_change.sh reject <id>  # 拒绝
```

---

## 9. 一句话总结

AoYi 外挂大脑系统是：

**"用 prompt 驱动 AI 智能、用 markdown 承载一切、用分形结构组织知识、用最少的代码做最必要的事的个人认知操作系统。"**
